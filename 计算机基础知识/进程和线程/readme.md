# 进程(process) 和 线程(thread)

- 多进程: multi-process
- 单线程: single thread 
- JS 运行在: 单个进程(Process)的单个线程(thread)上.
    + 好处是: 在没有多线程的情况下, 没有锁, 没有线程同步问题. 


## 目录(Catalog)
- 线程和进程的区别是什么？
- 概述一下 Node.js 中的进程和线程.





## 生词(New Words)
- **central ['sɛntrəl] --adj.中央的; 中心的; 主要的; 中枢的**
    + Central Processing Unit. 中央处理器
    + the central area['ɛrɪə] of the city. 城市的中心区.(城中区)
    + the central aim of this investigation. 这项调查的主要目的.
    + the central post office. 中央邮局.
- **process ['prəʊses]/['prɑsɛs] --n.过程; 进程; 进行; 程序; 工程.**
  **--vt.加工; 处理.** (Tip: 注意 UK 和 US 中 O 发音不同)
    + the process(n) of history. 历史的演进.
    + in process of construction. 建筑[工程进行]中 
    + in process(n) of time. 随着时间的推移, 逐渐地.
    + They were in the process(n) of forming a plan. 他们正在拟定计划
    + The process(n) for[of] making steel is complex. 钢铁的制造程序很复杂.


## 内容(Content)
### 线程和进程的区别是什么？
> [文章来源](https://www.zhihu.com/question/25532384) : 最高票 zhonyong 的回答.
- 首先一句话概括: **进程和线程都是一个时间段的描述, 是 CPU(central processing unit)**
  **工作时间段的描述.**
- 下面细说背景:
    + CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，
      但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。
    + **一个最最基础的事实:** CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，
      RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？
      轮流着来? 或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。
    + **一个必须知道的事实** 执行一段程序代码，实现一个功能的过程介绍 ，当得到 CPU 的时候，
      相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行. 
      这里除了 `CPU` 以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。
      当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，
      等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，
      因为这个是下次他被 `CPU` 临幸的运行环境，必须保存.  
      (tip: 从这里可以联想到 JS 的执行上下文, 浏览器像是充当了 cpu 的角色, JS代码就绪后,
      浏览器的执行从其他线程切换到 JS引擎线程, JS引擎工作便会创建全局执行上下文. 
      全局执行上下文就类似于上面所说的程序上下文)
    + **串联起来的事实**: 前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，
      具体的轮流方法就是：**先加载程序 A 的上下文, 然后开始执行 A, 保存程序 A 的上下文,**
      **调入下一个要执行的程序 B 的程序上下文, 然后开始执行 B, 保存程序 B 的上下文...**
    + 进程和线程就是在这样的背景下产生的, **两个名词不过是对应的 CPU 时间段的描述,**
      **名词就是这样的功能.**
- **`进程(Process)`** 就是`包含上下文切换的程序执行时间总和` = `CPU加载上下文` + 
  `CPU 执行` + `CPU 保存上下文`.
- **`线程(Thread)`**是什么?
    + 进程的颗粒度太大, 每次都要有上下的调度, 保存, 调出. 
      如果我们把进程比喻为一个运行在电脑上的软件, 那么一个软件的执行不可能是一条逻辑执行的,
      必定有多个分支和多个程序段, 就好比要实现程序A, 实际分成 a, b, c 等多个块组合而成.
      那么这里具体的执行就可能变成: 程序 A 得到 CPU  = CPU 加载上下文,
      开始执行程序 A 的 a 小段, 然后执行 A 的 b小段, 然后再执行 A 的 c 小段,
      最后 CPU 保存 A 的上下文.  这里 a, b, c 的执行时共享了 A 的上下文,
      CPU 在执行的时候没有进行上下文切换的. 
      **这里的 a, b, c 就是`线程`: 也就是说线程是共享了进程的上下文环境的更为细小的CPU时间段.**
 - 总结: **进程和线程都是一个时间段的描述, 是 CPU 工作时间段的描述, 不过是颗粒大小不同.**      
 - Note: 更专业的说法是 -- **进程是cpu资源分配的最小单位,线程是cpu调度的最小单位.**



### 概述一下 Node.js 中的进程和线程.

- Node.js 中的`进程`(`Process`) 是一个全局对象, 无需 `require` 直接使用, 
  给我们提供了当前进程中的相关信息. Node.js 中进程可以使用 `child_process`
  模块创建.
- 关系:
    + (1) 一个线程(thread)只能属于一个进程, 而一个进程可以有多个线程,
      但至少有一个线程(通常说的主线程).
    + (2) 统一进程的所有线程共享该进程的所有资源.
    + (3) 进程在执行过程中, 需要协作同步. 不同进程的线程间利用`消息通信`
      的办法实现同步.
    + (4) 处理机分给线程, 即真正在处理机上运行的是线程.
    + (5) 线程是指进程内的一个执行单元, 也是进程内的可调度实体.
- 区别:
    + (1) 调度: 线程作为调度和分配的基本单元, 进程作为拥有资源的基本单元.
    + (2) 拥有资源: 进程是拥有资源的一个独立单位, 线程不拥有系统资源,
      但可以访问隶属于进程的资源.