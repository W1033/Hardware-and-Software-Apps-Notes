<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
  <head>
    <title>16　存储器组织</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="../page_styles.css"/>
</head>
  <body class="calibre">

<h1 id="txt016_1" class="sect">16　存储器组织</h1>
<p class="content">每天清晨，我们将自己从沉睡中唤醒，这时大脑的空白会很快被记忆填充。我们立刻会意识到自己身在何方，最近做了些什么事情，有什么计划和打算。有的事情我们很快就能想起来，但有时，我们大脑处于失忆状态，有那么几分钟发现自己什么都想不起来（就拿我来说，有时我就是想不起来怎么我上床时还穿着袜子），但总的来说，我们总是能够与自己的过去保持足够的连续性，继续新的生活，展开人生新的一页。</p>
<p class="content">显然，人类的记忆似乎没有什么规律。仔细回想高中的几何课，或许你一下子就能想到是谁坐在你前面，或许你清晰地记得当老师讲到QED（quod erat demonstrandum，证明与推论）这个概念的时候消防演习开始了。</p>
<p class="content">人类的记忆也并非能面面俱到。书面记录这种技术的引入，从某种层面来讲，就是为了弥补人类记忆容易遗漏这一缺陷。或许在某天夜里凌晨三点，你从床上一跃而起，脑海中突然出现某个剧本的绝妙灵感。你立刻抓起床边提前预备的笔和纸，将它们全部记下防止遗忘，然后才安然入睡。一觉醒来的清晨，再次浏览这个绝妙的灵感，一个新的剧本构想跃然纸上（剧本的内容就是“一次邂逅，汽车追尾与爆炸”?仅此而已吗？）或许远不如此。</p>
<p class="content">我们总是将需要的记住的内容事先记下来，在需要时拿出来阅读；习惯于将可能用到的事物先存起来，在需要时将它们取出。从技术角度来讲，这个过程称为先存储后访问。存储器的职责和作用就在于此，它负责保障这两个过程之间信息完好无损。我们每次存储信息都要利用不同种类的存储器。比如，保存文本信息的不二之选就是纸张，而磁带则更适于存储音乐和电影。</p>
<p class="content">电报继电器（Telegraph Relays）——以一定形式组织起来构成逻辑门，然后再形成触发器——同样具备保存信息的能力。在前面章节中我们讨论过，一个触发器可以对1位信息进行存储。这样的存储能力要存储一大堆的信息还远远不够，但它却为我们达到目标迈出了坚实的一步。其实知道了如何存储1位信息，很容易就可以想象出如何存储2位、3位或更多位信息。</p>
<p class="content">在第14章的学习过程中，我们一起讨论过由一个反向器、两个与门和两个或非门构成的D型电平触发器，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00433.jpeg" class="picture_figure343"/></div>
<p class="content">当时钟输入为1，Q端输出与数据端输入保持一致。但当时钟输入跳变为0时，Q端输出将保持数据端最后一次的输入。除非时钟输入再次还原为1，之后的数据端输入不会影响输出。此触发器的真值表如下。</p>
<div class="picture_figure"><img alt="img" src="../images/00434.jpeg" class="picture_figure344"/></div>
<p class="content">在第14章的讨论中，这种触发器可以由两种不同特性的电路来实现，而在本章我们仅选择其中一种——目的就只是为了保存1位信息。为了更加清楚地表述，我们给输入和输出端重新命名，使其名称与功能相符，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00435.jpeg" class="picture_figure345"/></div>

<p class="content">从结构上来讲，这套电路与先前所学到的是同一种触发器，只是命名的方式不尽相同，现在Q输出端被称为数据输出端（Data Out），时钟输入端（在第14章叫做保持位）命名为写操作端（Write）。就像信息可以被记录在纸上一样，写操作端的信号同样使得数据输入（Data In）信号被写入（Written Into），也可以称之为被存储（stored）到电路中。一般情况下，如果写操作端为0，则数据输入信号的状态对输出无影响。而当我们想把数据输入信号存储在触发器中时，可以把写入信号应先置1后置为0。在第14章讲到过，这种类型的电路也被称为锁存器，因为存储进去的数据就好像被锁住了一样。下面给出了1位锁存器简化框图，框图未画出其内部结构中的部件。</p>
<div class="picture_figure"><img alt="img" src="../images/00436.jpeg" class="picture_figure346"/></div>
<p class="content">我们很容易想到如何把多个1位锁存器组织成为多位锁存器，所要做的就是把写操作端的信号连接到系统中，就像下面这样。</p>
<div class="picture_figure"><img alt="img" src="../images/00437.jpeg" class="picture_figure347"/></div>
<p class="content">图中显示的8位锁存器其输入和输出端各有8个。另外还包括一个写操作端，在非工作状态下一般为0。如果要把一个8位二进制数存储在锁存器中，首先要把写操作端置1，然后置0。我们同样可以把这个锁存器以框图的形式表现出来，就像下面这样。</p>
<div class="picture_figure"><img alt="img" src="../images/00438.jpeg" class="picture_figure348"/></div>
<p class="content">为了和先前提到的1位锁存器保持一致，我们将它可以画成下面这种形式。</p>
<div class="picture_figure"><img alt="img" src="../images/00439.jpeg" class="picture_figure349"/></div>
<p class="content">还有另一种方法集成8个1位锁存器，但其结构并不像上面的这样直观。假设我们只想用一个数据输入和输出信号端，而且希望锁存器能将输入信号数据分8次独立存储，这个任务可以在长达一天内完成，或者可能迅速在下一分钟内搞定。最后一项要求就是我们还希望能够通过观察数据输出信号端确定实际的8位输出。</p>
<p class="content">换句话说，在这种锁存器中我们只想存储8个单独的比特，而不是存储1个8位二进制数。</p>
<p class="content">为什么会有这种需求呢？原因可能在于仅有一个灯泡！</p>
<p class="content">我们知道现在所需要的是8个1位锁存器。先不去考虑数据如何存储在这些锁存器中，把重点放在如何用一个灯泡来确定锁存器的数据输出信号。最简单的方法就是把这个灯泡依次连接到每个锁存器上，分若干次来测试各个锁存器的输出，但是我们要追求更加自动化的方法。用开关来选择想要检查的锁存器是一个好的办法。</p>
<p class="content">究竟需要多少个开关才能解决问题呢？我们可以把这个过程进一步抽象，问题变成了怎么样从8个物体中选出一个我们想要的，我们需要3个开关。这是因为通过3个开关连通与闭合的排列组合，总共可表示出8个不同的值：000、001、010、011、100、101、110和111。</p>
<p class="content">现在我们手头上已有8个1位锁存器、3个开关、1个灯泡，此外在开关和灯泡之间还有另外一种装置，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00440.jpeg" class="picture_figure350"/></div>

<p class="content">这个“额外装置”就是图中的神秘盒子，顶部带有8个输入端，左侧也带有3个输入端。通过三个开关的闭合和断开，对顶部的输入进行8选1操作，输出结果被传递到其底部连接的灯泡，使其发光。</p>
<p class="content">上图标注的“这是什么装置？”到底是什么呢？我们先前曾碰见过类似的东西，当时讨论的装置没有这么多的输入端。这种装置曾出现在第14章中第一个改进的加法机的电路中。在该电路中要在一行开关和一个锁存器的输出之间选择一个，作为加法器的输入，当时称其为2-1选择器。而我们现在所需要的正是8-1数据选择器（8-Line-to-1-Line Data Selector）。</p>
<div class="picture_figure"><img alt="img" src="../images/00441.jpeg" class="picture_figure351"/></div>
<p class="content">8-1选择器有8个数据输入端（在其顶部），以及3个选择输入端（在其左侧）。选择输入端的功能就是选择一个输入端数据，然后使其在输出端输出。如果选择输入端为000，则将D<span class="subscript">0</span>锁存器的值输出；若选择端为111，则D<span class="subscript">7</span>锁存器的值将被输出；若选择端为101，则相应地输出D<span class="subscript">5</span>的值。系统的真值表如下所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00442.jpeg" class="picture_figure352"/></div>
<p class="content">8-1选择器主要组成部件为：三个反向器、八个4端口输入与门、一个8端口输入或门，系统的组织结构如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00443.jpeg" class="picture_figure353"/></div>
<p class="content">这个电路看上去线路密布，要理解它是如何工作的，最好方式就是一起来看一个例子。假设S2初始化为1，S1初始化为0，S0初始化为1。从顶部开始的第6个与门的输入由S0、<img src="../images/00444.jpeg" class="picture_formula_line3" alt="img"/>、S2组成，初始状态下它们全为1。其余与门的这三项输入数据都与第6个与门不尽相同，这使得其余与门输出全部为0。若D5变为0意味着第6个与门输出为0；反之第6个与门输出则为1。对最右边的或门也可以按照同样的方式理解。我们可以总结出下面这个结论：若选择端为101，则数据输出端与D5的输出保持一致。</p>
<p class="content">让我们重新理一下思路，想想自己究竟要干什么。我们的目的是通过某种方式连接8个1位锁存器，使自己能够从一个输入信号端写入数据，还能从一个输出信号端鉴别出数据。现在我们已经成功地使用了一个8-1选择器对8个锁存器进行了选择操作，并将相应锁存器的数据输出，下面是电路的结构图。</p>
<div class="picture_figure"><img alt="img" src="../images/00445.jpeg" class="picture_figure354"/></div>
<p class="content">到这里我们只走完了长征的一半。既然输出端已经满足了要求，现在把注意力集中到输入端。</p>
<p class="content">输入端包括了数据输入信号及写操作信号。可以把所有数据输入信号在锁存器的输入端连接在一起。但8个写入信号是不可以连在一起的，因为我们很可能要向每个锁存器依次写入数据。除此之外还需要一个独立的写入信号，它能被路由到任意（且唯一）的锁存器上，系统的结构可用下图表示。</p>
<div class="picture_figure"><img alt="img" src="../images/00446.jpeg" class="picture_figure355"/></div>

<p class="content">为了能圆满完成任务，我们需要另外一款电路元件，而且这款元件与8-1选择器功能类似，但它的作用正好相反。我们所说的正是3-8译码器（3-to-8 Decoder）。前面的章节中我们曾学习过一个简易的数据译码器（Data Decoder）——在第11章中为了选择喜欢的猫咪的毛色，我们把开关以一定方式进行连接使其具有选择功能。</p>
<p class="content">3-8译码器的输出端口共有8个。在任何时刻，译码器只会有一个锁存器的输出为1，其余均为0。每一个输出端的结果都是由S<span class="subscript">0</span>、S<span class="subscript">1</span>、S<span class="subscript">2</span>这三个信号的排列组合决定的。而数据的输出和输入一致，如下图所示。</p>

<div class="picture_figure"><img alt="img" src="../images/00447.jpeg" class="picture_figure356"/></div>
<p class="content">我想再次强调一遍：注意从上往下数的第6个与门，它的输入包括S<span class="subscript">0</span>、<img src="../images/00448.jpeg" class="picture_formula_line4" alt="img"/>、S<span class="subscript">2</span>。没有任何一个与门具有和它相同的三个输入。在这种情况下，如果选择输入端为101，则除了O<span class="subscript">5</span>要根据情况进行判定外，其余与门输出都为0。这个时候，若数据端输入为0，则O<span class="subscript">5</span>随之输出为0；相应的，若数据端输入为1，则O<span class="subscript">5</span>输出为1。译码器的逻辑表可以如下表所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00449.jpeg" class="picture_figure357"/></div>
<p class="content">将8个锁存器加入到电路就形成了完整的系统。</p>
<div class="picture_figure"><img alt="img" src="../images/00450.jpeg" class="picture_figure358"/></div>

<p class="content">值得注意的是，译码器和选择器具有相同的选择信号，在上图中这三个信号一起被称为地址端口（Address）。地址的作用就像我们平时使用的邮箱号，长度为三位的地址决定了8个锁存器中的哪一个将被引用。在3-8译码器的输入端，地址起到了决定哪些锁存器可以被写操作端的信号触发来保存数据的作用。在输出端（图的下半部分），8-1选择器通过地址来选择8个锁存器中的一个，最后将其输出。</p>
<p class="content">这种配置下的锁存器在有的资料中也被称为读/写存储器（read/write memory），但更普遍的叫法是随机访问存储器（Random Access Memory），或RAM（和单词animal发音类似）。可以认为我们讨论的这种存储器是可存储8个独立比特的RAM，它的简化结构图如下所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00451.jpeg" class="picture_figure359"/></div>
<p class="content">上图所示的电路之所以能够被称为存储器是因为它可以保存信息。而能够被称为读/写存储器是因为它不仅可以在每个锁存器中存储新的数据（可以把这种功能称为写数据），而且我们还可以检查每个锁存器都保存了什么数据（可以把这种功能称为读数据）。之所以可以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及相关的输入，就可以从8个锁存器中读出或写入需要的数据。相反，一些其他类型的存储器必须按顺序读取——也就是说，如果想要读取地址为101的数据，你将不得不先把地址为100的数据读出来。</p>
<p class="content">将RAM进行特殊的配置可形成RAM阵列（Array），我们所讨论的这种RAM阵列以8×1（读做8乘1）的方式组织起来。阵列以1比特作为存储单位，共存储8个单位的数据。所以这个RAM阵列中能存储的位数等于8与1的乘积。</p>

<p class="content">RAM阵列的组合形式多种多样。比如我们可以通过共享地址的方式可以把两个8×1的RAM阵列连接起来，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00452.jpeg" class="picture_figure360"/></div>
<p class="content">我们把这两个8×1的RAM阵列的地址和输出都分别看成一个整体，这样就得到了一个8×2的 RAM阵列，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00453.jpeg" class="picture_figure361"/></div>
<p class="content">这个RAM阵列可存储的二进制数依然是8个，但每个数的位宽为2位。</p>
<p class="content">我们还可以把两个8×1的RAM阵列看做是两个锁存器，使用一个2-1选择器和一个1-2译码器就可以把它们按照单个锁存器连接方式进行集成，下面给出了这种方案的电路图。</p>
<div class="picture_figure"><img alt="img" src="../images/00454.jpeg" class="picture_figure362"/></div>

<p class="content">“选择”端之所以连接到译码器和选择器，主要作用是在两个8×1 RAM阵列中选择一个，本质上它扮演了第4根地址线的角色。因此这种结构实质上是一种16×1 的RAM 阵列，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00455.jpeg" class="picture_figure363"/></div>
<p class="content">上图所示的RAM阵列存储容量为16个单位，每个单位占1位。</p>
<p class="content">RAM阵列的存储容量与其地址输入端的数量有直接的联系。在没有地址输入端的情况下（只有1位锁存器和8位锁存器的情况），只能存储1个单位的数据；当存在1个地址输入端时，可以存储2个单位的数据；有两个地址输入端时，可以存储4个单位的数据；有3个地址输入端时，可以存储8个单位的数据；有4个地址输入端时，可以存储16个单位的数据。我们可以把它们之间的关系归纳成如下等式：</p>

<p class="content_center"><span class="emphasis_bold">RAM阵列的存储容量 = 2</span><span class="superscript">地址输入端的个数</span></p>
<p class="content">前面已经向大家演示了怎么搭建小型RAM阵列，你可能会问：为什么不搭建一个大规模的RAM阵列呢？就像下面这样。</p>
<div class="picture_figure"><img alt="img" src="../images/00456.jpeg" class="picture_figure364"/></div>
<p class="content">上图所示的RAM阵列可存储8192个比特的信息，每8个比特为一组，共分为1024个组。因为2的10次方恰好是1024，所以地址端共有10个输入端口。电路还包括8位的数据输入端和8位的数据输出端。</p>
<p class="content">从专业的角度来讲，这个RAM 阵列的存储容量为1024个字节。就好比一个邮局放置了1024个邮箱，而每个邮箱里面都可以存放1字节大小的邮件（希望不是垃圾邮件）。</p>
<p class="content">1024字节通常简称为1 千字节（kilobyte），1K这种称呼不可避免地要引起许多混淆。其中它的前缀kilo（源于希腊文khilioi，意思为1000），经常在公制系统中用到。比如1千克（ kilogram）代表着 1000 克（grams）； 1 千米（kilometer）代表着 1000 米（meter）。有所不同的是，这里所说的1千字节却代表着 1024个字节——并非1000个字节。</p>
<p class="content">它们之间不同的根本原因在于公制系统是基于10的幂的计数系统，而计算机采用的是基于2的幂的计数系统，它们之间没有交集。比如10的幂为10、100、1000、10000、100000等，而2的幂为2、4、8、16、32、64等。我们可以证明不存在一对整数a和b使得10的a次幂与2的b次幂相等。</p>
<p class="content">但是偶尔也会碰见非常接近的数字。事实的确如此，1000十分接近1024，用数学化的描述方法可以称这种关系为“约等于”，这样我们可以得到相应的数学表达式：</p>
<p class="content_center">2<span class="superscript">10 </span>≈ 10<span class="superscript">3</span></p>
<p class="content">这个表达式并非空穴来风，它真正的意义在于表明2的某次幂和10的某次幂几乎相等。我们利用这一巧合可以很方便地把1024个字节的存储空间用1千字节来表示。</p>

<p class="content">千字节可以简写为KB。这样我们可以说前面所讲过的那个RAM阵列存储能力为1024个字节，也可以说成是1KB。</p>
<p class="content">绝不能认为1KB的RAM阵列的存储能力为1000字节，它实际上是大于1000字节，是1024个字节，为了准确而清晰地表达你脑海中的数据，我们可以使用“1 KB””或“1千字节”这两种通用的表述方式。</p>
<p class="content">存储容量为1KB的存储系统由8个数据输入端、8个数据输出端和10个地址输入端所组成。由于这些字节是由10个地址输入端来标识和访问的，所以这种RAM阵列存储容量为2<span class="superscript">10</span>个字节。如果我们再加上一条地址线，它的存储容量将变成原来的两倍。下面的公式表示了存储容量的翻倍的过程。</p>
<div class="picture_figure"><img src="../images/00457.jpeg" class="picture_figure365" alt="img"/></div>
<p class="content">请注意最左侧一排的数字也以2的幂的顺序逐步递增。</p>
<p class="content">我们把1024个字节简化成为了1 KB，相同的逻辑，我们把1024 KB统称为1兆字节（megabyte，希腊文中的mega意味着宏大），兆字节通常缩写为MB。下面这个例子表示了兆字节为单位的存储容量翻倍的过程。</p>
<div class="picture_figure"><img src="../images/00458.jpeg" class="picture_figure366" alt="img"/></div>

<p class="content">希腊文中的giga意味着巨大，1024 MB也就被顺其自然地称为1吉（gigabyte）字节，缩写为GB。</p>
<p class="content">同理，1太字节（terabyte，teras希腊语意思为巨人）表示2<span class="superscript">40</span>个字节（约为10<span class="superscript">12</span>），也就是1,099,511,627, 776个字节，太字节的缩写为TB。</p>
<p class="content">1 KB近似为1000个字节，1 MB近似为100万个字节，1 GB近似为10亿个字节，1 TB近似为1万亿个字节。</p>
<p class="content">比TB还高数量级平时一般很少使用，比如2<span class="superscript">50</span>个字节表示为1批字节（petabyte），计算出来就是1,125,899,906,842,624个字节，约等于一千万亿，即10<span class="superscript">15</span>字节。1安字节（exabyte）代表2<span class="superscript">60</span>个字节，也就是1,152,921,504,606,846,976个字节，约为100万的3次方，即10<span class="superscript">18</span>。</p>
<p class="content">我们来补充一些生活中的基本常识。在写本书时（1999年），家用电脑的随机存储器的容量一般为32 MB、64 MB或128 MB（为了避免混淆，这里的任何描述都不涉及硬盘驱动器的任何内容，范围仅仅限定为RAM），通过计算可以得到它们的存储大小分别为33,554,432个字节、67,108,864个字节和134,217,728个字节。</p>
<p class="content">简洁明了是我们人类交流方式的一大特色。比如，家中电脑内存大小如果为65,536字节，我们会说“我的是64 K（这句话很可能是在1980年听到的）”；家中电脑内存大小如果为33,554 ,432字节，我们会说“我的是32 M”。有少数电脑配备了1,073,741,824字节的内存，他们或许会说“我的可是上了G的（有时这句话的英文表述会让人误以为你在谈论音乐——I’ve got a gig）”。</p>

<p class="content">有时人们可能会用到千比特或兆比特（注意是比特而不是字节），这只是极少数情况。当我们讨论涉及存储器的相关问题时，通常使用的是字节数而非比特（需要的时候可以通过把字节数乘以8将其转换成比特）。有一种情况下我们会经常用到千比特和兆比特，那就是在描述在线路中流动的数据时，很多句子中经常会出现千比特每秒（kbps）或兆比特每秒（mbps）这些用语。例如，一台56K的调制解调器指的是其数据处理速度为56千比特每秒，而不是56千字节每秒。</p>
<p class="content">既然我们已经学会如何构造任意大小的RAM阵列，接下来继续对这个问题深究下去。假设现在已经构造好了一个容量为65,536字节的存储器组织，如下图所示。</p>
<div class="picture_figure"><img alt="img" src="../images/00459.jpeg" class="picture_figure367"/></div>
<p class="content">为什么选择大小为64 KB的RAM阵列？而非32 KB或128 KB？因为65,536是一个约整数，转换为幂的形式就是2<span class="superscript">16</span>，这个RAM阵列需要配备16位的寻址端。换句话说，该地址恰好可以用2个字节表示。将地址范围转化为十六进制就是 0000h～FFFFh。</p>
<p class="content">我前面也提到过，64 KB的内存是1980年的个人电脑的主流配置，但它的确不是用电报继电器组成的。我们可以用继电器来组成一块内存吗？我也相信你不想这么做。在我们先前的讨论中，存储每个比特需要9个继电器，推算一下64K×8的RAM阵列就需要至少500万个继电器！</p>
<p class="content">如果用一种控制面板来辅助我们管理对这块64KB存储器的操作——包括写数据和读数据，一切将会直观明了。在这款控制面板上，有16个开关用于控制地址位，还有8个开关用来控制要输入的8比特数据。写操作端也用一个开关来表示，8个灯泡用来显示8位数据，这个控制面板如下图所示。</p>
<p class="content">初始状态下所有的开关均置为0。其中右下角有一个标识为控制端（takeover）的开关，这个开关的作用是确定由控制面板还是由外部所连接的其他电路来控制存储器。如果其他电路连接到与控制面板相连的存储器，这时控制端置0（如图所示），此时存储器由其他电路系统接管，控制面板上的其他开关将不起任何作用；当控制端置1时，控制面板将重新获得对存储器的控制能力。</p>
<div class="picture_figure"><img src="../images/00460.jpeg" class="picture_figure368" alt="img"/></div>
<p class="content">这种功能可以用一些2-1选择器来实现。仔细数一下会发现，我们需要25个2-1选择器——其中包括16个地址输入端、8个数据输入端，以及1个写操作端。电路如下图所示。</p>
<p class="content">当控制端开关断开时，RAM阵列的地址端、数据输入和写操作端的数据全部来源于外部信号，也就是在2-1选择器的左上角的输入信号；当控制端开关闭合，RAM阵列的地址端、数据输入端和写操作端的数据来源于控制面板开关发出的信号。但最终RAM阵列的输出信号都会传输到8个灯泡上或其他可能的地方。</p>
<div class="picture_figure"><img alt="img" src="../images/00461.jpeg" class="picture_figure369"/></div>

<p class="content">下面这幅是控制面板与64K×8 RAM阵列的逻辑结构框图。</p>
<div class="picture_figure"><img alt="img" src="../images/00462.jpeg" class="picture_figure370"/></div>
<p class="content">当控制端开关闭合时，通过操作16个地址开关，可以选择65,536个地址中的任何一个，灯泡的状态将表示该地址中所保存的8位数据。我们可以使用8个数据开关表示出一个新数，然后把写操作端置1，从而将数据写入存储器。</p>
<p class="content">64K×8的RAM阵列和控制面板这一组合的确很实用，它可以帮助我们存储65,536个8位数据并且读取其中的任意一个。与此同时，我们也给其他部件提供了接入系统的机会——需要接入系统的通常是一些电路部件——这些部件可以轻易地读取并利用存储器中存放的数据，还可以把数据写入存储器。</p>
<p class="content">关于存储器有一个问题尤其值得我们注意，而且需要特别注意。在学习第11章的时候，我们曾介绍过逻辑门的概念及原理，但是没有画出组成逻辑门的单个继电器的结构图。特别是，当时没有指明每个继电器都与某个电源连接在一起。只要继电器连通，电流就会流过电磁线圈并产生磁场，继而吸下金属片。</p>
<p class="content">一个辛辛苦苦装满65,536字节珍贵数据的64 K×8 RAM阵列，如果断掉电源，会发生什么事情呢？首先所有的电磁铁都将因为没有电流而失去磁性，随着“梆”的一声，金属片将弹回原位，所有继电器将还原到未触发状态。RAM中存储的数据呢？它们将如风中残烛般消失在黑暗中。</p>
<p class="content">正因为如此，随机访问存储器也被称为易失性（volatile）存储器。为了保证存储的数据不丢失，易失性存储器需要恒定的电流。</p>
</body></html>
